# teletext-twitter - creates pages for vbit2 teletext system
# (c) Mark Pentler 2018 (https://github.com/mpentler)
# see README.md for details on getting it running

import twitter
import time
import sys
import textwrap

# Read config.py for our access keys etc
config = {}
exec(open("config.py").read(), config)
twitter = twitter.Api(access_token_key = config["access_key"],
                      access_token_secret = config["access_secret"],
                      consumer_key = config["consumer_key"],
                      consumer_secret = config["consumer_secret"],
                      sleep_on_rate_limit = True) # so we don't hit the rate limit and raise an exception

# define our control codes here for easy use later
ESCAPE = chr(27)
RED = ESCAPE + chr(65)
GREEN = ESCAPE + chr(66)
YELLOW = ESCAPE + chr(67)
BLUE = ESCAPE + chr(68)
MAGENTA = ESCAPE + chr(69)
CYAN = ESCAPE + chr(70)
WHITE = ESCAPE + chr(71)

def write_header():
    with open("/home/pi/teletext/P153.tti", "w+") as file:
        file.write("DE,Autogenerated by Teletext-Twitter\r\n")
        file.write("PN,15300\r\n")
        file.write("SC,0000\r\n")
        file.write("PS,8000\r\n")
        file.write("OL,1," + chr(27) + chr(77) + "TELETEXT TWITTER" + chr(27) + chr(86) + (chr(127) * 22) + "\r\n")
        file.write("OL,3," + chr(27) + chr(86) + (chr(35) * 39) + "\r\n")

def write_timeline(): # grab the latest timeline - only 5 tweets for now
    statuses = twitter.GetHomeTimeline(count = 5)
    line_position = 4

    for status in statuses: # iterate through our responses
        tweet_time = time.strptime(status.created_at,"%a %b %d %H:%M:%S +0000 %Y")
        tweet_human_time = time.strftime("%d-%b-%Y %H:%S", tweet_time) # reformat time/date output
        tweet_username = status.user.screen_name
        tweet_text = textwrap.wrap(status.text, 39) # make sure our lines fit on the screen

        if (line_position + len(tweet_text) + 1) > 24: # are we going to fill the page?
            break # yep! dump the last tweet!

        with open("/home/pi/teletext/P153.tti", "a") as file:
            file.write("OL,{},".format(str(line_position)) + ("`" * (36-len(tweet_human_time)-len(tweet_username))) + "@{}".format(tweet_username) + " | " + "{}".format(tweet_human_time) + "\r\n")
            line_position += 1
            for line in tweet_text:
                line = line.replace("â€™", "'")
                line = line.replace("_", "-")
                line = line.replace("#", "_")
                file.write("OL,{},".format(str(line_position)) + RED + "{}\r\n".format(line))
                line_position += 1

def main():
    print("[*] teletext-twitter - (c) 2018 Mark Pentler (https://github.com/mpentler)", file=sys.stdout)
    print("[*] Beginning timeline scraping", file=sys.stdout)

    # for now we'll update for 60 seconds - may want to make this changeable?
    while True:
        write_header()
        write_timeline()
        print("[*] Waiting 60 seconds until next scrape", file=sys.stdout)
        time.sleep(60)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("[!] Interrupted by user. Exiting...", file=sys.stdout)
        sys.exit(0)
